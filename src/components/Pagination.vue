<template>  <div :class="classes.wrapperClass">    <span v-if="showPrevNext" :class="classes.itemClass">      <button          :disabled="hasPrev"          :class="[classes.btnClass, classes.prevNextClass]"          @click="prevPage"      >        <slot name="prevPage"> Prev </slot>      </button>    </span>    <template v-for="(page, index) in renderBtnsArray">      <span          v-if="hasRenderDots(index)"          :key="index + 100"          :class="[              hasHideDot(index),              classes.itemClass,              classes.breakViewClass          ]"      >        <slot name="breakView"> ... </slot>      </span>      <span          :key="index"          :class="[classes.itemClass, hasHideNavBtn(page)]"      >        <button            :class="[setActiveClass(page), classes.btnClass]"            @click="updatePage(page)"        >          {{ page }}        </button>      </span>    </template>    <span v-if="showPrevNext" :class="classes.itemClass">      <button          :disabled="hasNext"          :class="[classes.btnClass, classes.prevNextClass]"          @click="nextPage"      >        <slot name="nextPage"> Next </slot>      </button>    </span>  </div></template><script>const DELTA = 1const RADIUS = 2const FIRST_PAGE_INDEX = 0const AFTER_FIRST_ELEMENTS_INDEX = 2const EMIT_NAME = 'input'const EMPTY = ''export default {  name: 'Pagination',  props: {    value: {      type: Number,      required: true,    },    perPage: {      type: Number,      required: true,    },    total: {      type: Number,      required: true,    },    pageRange: {      type: Number,      default: RADIUS,    },    showPrevNext: {      type: Boolean,      default: true,    },    classes: {      type: Object,      default: () => ({        wrapperClass: 'v-simple-pagination',        itemClass: EMPTY,        btnClass: EMPTY,        breakViewClass: EMPTY,        prevNextClass: EMPTY,      }),    },    activeClass: {      type: String,      default: 'active',    },    btnHideClass: {      type: String,      default: 'hide',    },  },  computed: {    /**     * D = 2 * R     * @return {number}     */    diameter() {      return this.pageRange * RADIUS;    },    /**     * Number of pages     * @return {number}     */    countOfPages() {      const ZERO = 0;      return Math.ceil(this.total / this.perPage) || ZERO;    },    /**     * @return {number[]}     */    renderBtnsArray() {      const array = [DELTA];      const firstPage = this.value - this.getDynamicRadius;      const lastPage = this.value + this.getDynamicRadius;      for (let i = firstPage; i <= lastPage; i++) {        if (i >= DELTA && i <= this.countOfPages) {          array.push(i);        }      }      array.push(this.countOfPages);      return array.filter((item, index) => array.indexOf(item) === index);    },    /**     * @return {number}     */    pageIndex() {      return this.value - DELTA;    },    /**     * Dynamic radius to distribute the visibility of points     * @return {number}     */    getDynamicRadius() {      if (          this.pageIndex === FIRST_PAGE_INDEX ||          this.pageIndex === this.countOfPages - DELTA      ) {        return this.diameter;      }      if (          this.pageIndex === DELTA ||          this.pageIndex === this.countOfPages - AFTER_FIRST_ELEMENTS_INDEX      ) {        return this.diameter - DELTA;      }      return this.pageRange;    },    /**     * Bottom of visible border elements     * @return {number}     */    bottomOfBorder() {      return this.pageIndex - this.renderBtnsArray.length;    },    /**     * Top of visible border elements     * @return {number}     */    topOfBorder() {      return this.pageIndex + this.renderBtnsArray.length;    },    /**     * @returns {boolean}     */    hasPrev() {      return this.value <= DELTA    },    /**     * @returns {boolean}     */    hasNext() {      return this.value >= this.countOfPages    },  },  methods: {    /**     * @param {number} page     * @return {string}     */    setActiveClass(page) {      return page === this.value ? this.activeClass : EMPTY;    },    /**     * @param {number} page     * @return {string}     */    hasHideNavBtn(page) {      const pageIndex = page - DELTA;      const hide = !(pageIndex >= this.bottomOfBorder && pageIndex <= this.topOfBorder) &&          !this.hasFirstOfLastPage(page);      return hide ? this.btnHideClass : EMPTY;    },    /**     * @param {number} index     * @return {boolean}     */    hasRenderDots(index) {      const sufficientNumberOfElements =          this.countOfPages > this.diameter; // sufficient number of the elements      const isSecondIndex = index === DELTA; // should render after first of the element      const isBeforeListIndex =          index === this.renderBtnsArray.length - DELTA; // should render before last of the element      return sufficientNumberOfElements && (isSecondIndex || isBeforeListIndex);    },    /**     * @param {number} index     * @return {string}     */    hasHideDot(index) {      let hide = this.renderBtnsArray.indexOf(this.countOfPages - DELTA) >= FIRST_PAGE_INDEX;      if (index === DELTA) {        hide = this.renderBtnsArray.indexOf(AFTER_FIRST_ELEMENTS_INDEX) >= FIRST_PAGE_INDEX;      }      return hide ? this.btnHideClass : EMPTY;    },    /**     * @param {number} page     * @return {boolean}     */    hasFirstOfLastPage(page) {      return page === DELTA || page === this.countOfPages;    },    /*--- EMIT OF PAGE NUMBER ---*/    nextPage() {      if (this.value < this.countOfPages) {        const currentPage = this.value + DELTA;        this.input(currentPage);      }    },    prevPage() {      if (this.value > DELTA) {        const currentPage = this.value - DELTA;        this.input(currentPage);      }    },    /**     * @param {number} index     */    updatePage(index) {      if (index !== this.value) {        this.input(index);      }    },    /**     * @param {number} page     * @return {number}     */    input(page) {      this.$emit(EMIT_NAME, page);    },  },}</script>